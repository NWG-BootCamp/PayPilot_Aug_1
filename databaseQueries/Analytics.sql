-- task-> Write a query to show total due amount per user. Group by user.
-- RITHIK
SELECT
    u.name AS "User Name",
    SUM(b.amount - NVL(p.total_paid_per_bill, 0)) AS "Total Due Amount"
FROM
    users u
INNER JOIN
    bills b ON u.user_id = b.user_id
LEFT JOIN
    (
        SELECT
            bill_id,
            SUM(amount_paid) AS total_paid_per_bill
        FROM
            payments
        GROUP BY
            bill_id
    ) p ON b.bill_id = p.bill_id
GROUP BY
    u.name
ORDER BY
    "Total Due Amount" DESC;


-- task-> Create a materialized view to precompute total unpaid bills for each user.
-- ANIMESH
CREATE MATERIALIZED VIEW mv_total_unpaid_bills_per_user
BUILD IMMEDIATE
REFRESH ON DEMAND
AS
SELECT 
    user_id,
    COUNT(*) AS unpaid_bill_count,
    SUM(amount) AS total_unpaid_amount
FROM 
    Bills
WHERE 
    is_paid = 0
GROUP BY 
    user_id;


--task->nested query to show users who have never paid any bill.
-- SALONI
SELECT name, email
FROM users
WHERE user_id NOT IN (
    SELECT DISTINCT user_id
    FROM bills
    WHERE is_paid = 1
);

--task->Index creation on due date.
--Shivam

CREATE INDEX due_date_idx ON bill(due_date);

-- HOW AN INDEX ON DUE_DATE OPTIMIZES PERFORMANCE --
-- 1. Enables faster lookups based on due_date. For example, when fetching records 
--    from the past few days to send reminders, the index allows quick access without scanning the entire table.
-- 2. Improves the efficiency of range queries, making it faster to retrieve records 
--    where due_date falls within a specified range.
-- 3. Speeds up queries that sort results by due_date, as the index maintains the column values 
--    in sorted order, reducing or eliminating the need for an additional sort operation.

--task-> Write a query to count users with more than 2 unpaid bills.
--Harshikha
SELECT 
    b.user_id,
    COUNT(*) AS unpaid_bill_count
FROM 
    Bills b
WHERE 
    b.is_paid = 0
GROUP BY 
    b.user_id
HAVING 
    COUNT(*) > 2;
    
--task--> Design a bill_category table and normalize category column from bills using FK.
--Harshikha
-- 1: Create BillCategory table
CREATE TABLE BillCategory (
    category_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    category_name VARCHAR2(100) UNIQUE NOT NULL
);

-- 2: Populate BillCategory from distinct values in Bills.bill_category
INSERT INTO BillCategory (category_name)
SELECT DISTINCT bill_category FROM Bills;

-- 3: Add category_id column to Bills
ALTER TABLE Bills ADD (category_id NUMBER);

-- 4: Update category_id in Bills using lookup from BillCategory
UPDATE Bills b
SET category_id = (
    SELECT bc.category_id
    FROM BillCategory bc
    WHERE bc.category_name = b.bill_category
);

-- 5: Drop the UNIQUE constraint that includes bill_category
-- Find constraint name dynamically if needed; assuming it is: uq_user_due_cat
ALTER TABLE Bills DROP CONSTRAINT uq_user_due_cat;

-- 6: Drop old bill_category column
ALTER TABLE Bills DROP COLUMN bill_category;

-- 7: Drop any existing FK on category_id if error was encountered previously
BEGIN
    EXECUTE IMMEDIATE 'ALTER TABLE Bills DROP CONSTRAINT fk_bill_category';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -2443 THEN -- ORA-02443: Cannot drop constraint - nonexistent
            RAISE;
        END IF;
END;
/

-- 8: Add the foreign key constraint for category_id
ALTER TABLE Bills
ADD CONSTRAINT fk_bill_category
FOREIGN KEY (category_id)
REFERENCES BillCategory(category_id);
